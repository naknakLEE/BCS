# BCS (Block Chain System)

본 프로젝트는 파이썬으로 구현된 간단한 블록체인 시스템입니다. 기본적인 블록체인의 구성 요소와 작동 방식을 시뮬레이션합니다.

## 주요 기능

- **블록 (Block):** 인덱스, 타임스탬프, 트랜잭션 목록, 이전 해시, 논스(Nonce), 머클 루트, 현재 해시를 포함합니다.
- **블록체인 (Blockchain):** 블록들의 체인으로, 작업 증명(Proof of Work), 블록 추가, UTXO 관리, 잔액 계산, 체인 유효성 검사 기능을 수행합니다.
- **트랜잭션 (Transaction):** 송신자, 수신자, 금액, 입력 목록, 출력 목록, 타임스탬프, 트랜잭션 ID, 서명을 포함합니다.
- **UTXO (Unspent Transaction Output):** 아직 사용되지 않은 트랜잭션 출력을 나타내며, 거래의 기본 단위입니다. `TransactionInput`은 UTXO를 참조하고, `TransactionOutput`은 새로운 UTXO를 생성합니다.
- **지갑 (Wallet):** 개인키, 공개키, 주소를 생성하고 트랜잭션에 서명 및 검증하는 기능을 제공합니다.
- **네트워크 노드 (NetworkNode):** 각 노드는 자신의 지갑과 블록체인 인스턴스, 멤풀(Mempool)을 가집니다. 트랜잭션 생성, 전파, 수신 및 블록 채굴, 전파, 수신 기능을 수행하며, 다른 노드와 피어(Peer)로 연결됩니다. 충돌 발생 시 가장 긴 체인을 선택하는 방식으로 해결합니다 (`resolve_conflicts`).
- **작업 증명 (Proof of Work):** 특정 난이도(difficulty) 조건을 만족하는 해시값을 찾기 위해 논스값을 변경해가며 반복적으로 해시 계산을 수행합니다.
- **P2P 네트워크 시뮬레이션:** 여러 네트워크 노드를 생성하고 서로 연결하여 트랜잭션과 블록이 전파되는 과정을 시뮬레이션합니다.

## 구성 요소 (Python 파일)

- `Block.py`: 블록의 구조와 해시 계산 (머클 루트 포함)을 정의합니다.
- `Blockchain.py`: 블록체인 로직 (블록 추가, PoW, UTXO 관리, 체인 검증 등)을 구현합니다.
- `Transaction.py`: 트랜잭션의 구조, 해시 계산, 서명 및 검증 로직을 담당합니다.
- `TransactionInput.py`: 트랜잭션의 입력 (사용될 UTXO)을 정의합니다.
- `TransactionOutput.py`: 트랜잭션의 출력 (새로운 UTXO)을 정의합니다.
- `Wallet.py`: 암호화 키 쌍 (개인키, 공개키) 및 주소 생성, 트랜잭션 서명/검증 기능을 제공합니다.
- `NetworkNode.py`: P2P 네트워크의 노드 역할을 하며, 트랜잭션과 블록의 생성, 전파, 처리 및 블록체인 동기화 로직을 포함합니다.
- `main.py`: 시뮬레이션을 실행하는 메인 스크립트입니다. 네트워크 노드들을 생성하고 연결하며, 트랜잭션 생성 및 블록 채굴 시나리오를 실행합니다.
- `const.py`: 블록체인 난이도 (`INITIAL_DIFFICULTY`), 채굴 보상 (`MINING_REWARD`) 등 상수 값을 정의합니다.
- `requirements.txt`: 필요한 파이썬 패키지 (현재는 `ecdsa`만 존재)를 명시합니다.
- `.gitignore`: Git 버전 관리에서 제외할 파일 및 폴더를 지정합니다.
- `LICENSE`: 프로젝트 라이선스 정보 (MIT License)를 포함합니다.
- `README.md`: 본 프로젝트 설명 파일입니다.

## 실행 방법

1.  **필수 패키지 설치:**

    ```bash
    pip install -r requirements.txt
    ```

    (주: `requirements.txt` 파일에 `ecdsa`가 포함되어 있어야 합니다. 현재 파일 내용에는 빠져있을 수 있으니 확인 후 추가하세요.)

2.  **시뮬레이션 실행:**
    ```bash
    python main.py
    ```
    `main.py` 파일은 여러 네트워크 노드를 생성하고, 트랜잭션 전송 및 블록 채굴 과정을 시뮬레이션하며, 각 노드의 블록체인 상태와 잔액을 출력합니다.

## 시뮬레이션 주요 과정 (`main.py`)

1.  여러 네트워크 노드 (`Node1`, `Node2`, `Node3`)를 생성하고, 각 노드의 난이도를 설정합니다.
2.  생성된 노드들을 서로 피어로 연결합니다.
3.  `Node1`이 첫 번째 블록 (코인베이스 트랜잭션만 포함)을 채굴합니다.
4.  다른 노드들은 `resolve_conflicts`를 통해 `Node1`의 체인으로 동기화합니다.
5.  `Node1`이 `Node2`에게 코인을 전송하는 트랜잭션을 생성하고 네트워크에 전파합니다.
6.  `Node3`가 위 트랜잭션을 포함하는 새로운 블록을 채굴합니다.
7.  다시 모든 노드가 체인을 동기화합니다.
8.  `Node2`가 `Node1`에게 코인을 전송하는 트랜잭션을 생성하고 네트워크에 전파합니다.
9.  `Node1`이 해당 트랜잭션을 포함하는 블록을 채굴합니다.
10. 모든 노드가 체인을 동기화합니다.
11. 각 노드의 최종 블록체인 요약, 지갑 잔액, 멤풀 크기를 출력하고, 대표 노드의 체인 유효성을 검사합니다.

## 참고

- 본 프로젝트는 교육 및 학습 목적으로 구현된 간단한 블록체인 시뮬레이션입니다. 실제 운영 환경에서 사용하기에는 보안 및 확장성 측면에서 많은 부분이 단순화되어 있습니다.
- 타원곡선 암호화 라이브러리로 `ecdsa`를 사용합니다.
- UTXO 모델을 기반으로 트랜잭션을 처리합니다.
- 머클 루트는 트랜잭션 ID들을 조합하여 간단하게 계산합니다.
- P2P 네트워크는 직접적인 객체 참조를 통해 시뮬레이션됩니다.
